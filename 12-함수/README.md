## 함수

> 자바스크립트 핵심개념인 스코프, 실행컨텍스트, 클로저, 생성자 함수에 의한 객체 생성 매서드, this, 프로토타입, 모듈화 등이 모두 함수와 깊은 관련이 있다.

- 프로그래밍 언어의 함수는 일련의 문으로 구현하고 코드블록으로 감싸서 하나의 실행 단위로 정의한 것이다.

```javascript
function add(x, y) {
  return x + y;
}
add(2, 5);
```

`함수는 코드의 중복을 억제하고 재사용성을 높여 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높인다`

## 함수 리터럴

> function 키워드, 함수이름, 매개변수 목록, 함수몸체로 구성

```javascript
var f = function add(x, y) {
  return x + y;
};
```

함수는 객체이다. 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.
그리고 일반 객체에는 없는 함수 객체만의 고유 프로퍼티를 갖는다

### 함수 정의

> 함수를 호출하기 전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것을 말함

1. **함수 선언문**

```javascript
function add(x, y) {
  return x + y;
}
```

2. **함수 표현식**

```javascript
var add = function (x, y) {
  return x + y;
};
```

3. **Function 생성자 함수**

```javascript
var add = new Function("x", "y", "return x+y");
```

4. **화살표 함수(ES6)**

```javascript
var add = (x, y) => x + y;
```

- 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 함수 객체를 할당한다.

- 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.

ex)

```javascript
var add = function add(x, y) {
  return x + y;
};
// 식별자          함수이름
console.log(add(2, 5));
/// 식별자
```

### 함수 생성 시점과 함수 호이스팅

> 함수선언문으로 작성하면 함수 선언문 이전에 호출가능
> -> 그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전헤 호출불가

이는 **함수 선언문**으로 정의한 함수와 **함수 표현식**으로 정의한 함수의 생성시점이 다르기 때문
함수선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유 특징을
`함수 호이스팅`이라 한다.

**변수 선언과 다른점**
-> 변수 선언은 런타임 이전에 실행되어 undefiend로 초기화되지만 변수할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수표현식의 함수리터럴도 할당문이 실행되는 시점에 평가되어 함수객체가 된다.

`따라서 함수표현식은 함수 호이스팅이 아니라 변수호이스팅이 발생한다.`

## 함수호출

> 매개변수는 함수몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다.
> 즉, 매개변수의 스코프(유효범위)는 함수 내부다.

ex)

```javascript
function add(x, y) {
  return x + y;
}
console.log(add(2)); // NaN -> 이는 매개변수 y가 undefined로 초기화된 상태
// x+y는 2+undefined라 NaN

console.log(add(2, 5, 10)); // 7 -> 이는 초과된 인수 10이 버려지는게아니라, 암묵적으로 arguments
// 객체의 프로퍼티로 보관됨
```

- ES6 매개변수 기본값

```javascript
function add(a = 0, b = 0, c = 0) {
  return a + b + c;
}
console.log(add(1, 2, 3)); // 6
console.log(add(1, 2)); // 3
console.log(add()); // 0
```

### 매개변수의 최대개수

- 이상적인 함수는 **한가지 일**만 해야하며 가급적 작게 만들어야 한다.
- 따라서 매개변수는 최대 3개 이상을 넘지 않은 것을 권함
- 만약 그 이상의 매개변수가 필요하면 하나의 매개변수를 선언하고 객체를 인수로 전하는것이 좋다.

---

### 다양한 함수의 형태

1. **즉시실행함수**
   > 함수 정의와 동시에 즉시 호출되는 함수. 즉시실행함수는 단 한번만 호출되며 다시 호출할 수 없다.

```javascript
(function () {
  var a = 3;
  var b = 5;
  return a * b;
})();
```

- 즉시실행함수는 반드시 그룹 연산자(...)로 감싸야 한다.

2. **재귀함수**
   > 자기자신을 호출하는 함수

```javascript
	function countdown(n){
      if(n<0) return
      console.log(n)
      countdown(n-1) // 재귀 호출
```

- 재귀함수는 반드시 탈출조건이 있어야한다.

3. **중첩함수**
   > 함수 내부에 정의된 함수를 중첩함수 또는 내부함수라 한다.
   > 그리고 중첩함수를 포함하는 함수는 외부함수라 한다.

```javascript
function outer() {
  var x = 1;
  // 중첩함수
  function inner() {
    var y = 2;
    // 외부함수의 변수를 참조할 수 있다
    console.log(x + y); // 3
  }
  inner();
}
outer();
```

4. **콜백함수**
   > 함수의 매개변수를 통해 다른함수의 내부로 전달되는 함수를 콜백함수라한다.
   > 그리고 매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수를 고차함수라 한다.

```javascript
function repeat(n) {
  for (var i = 0; i < n; i++) console.log(i);
}
repeat(5); // 0, 1, 2, 3, 4
```

- 고차함수는 매개변수를 통해 전달받은 콜백함수의 호출시점을 결정해서 호출한다.
  다시말해, 콜백함수는 고차함수에 의해 호출되며 이때 고차함수는 필요에 따라 콜백함수에 인수를 전달할 수 있다.

5. **순수함수와 비순수함수**
   > 1. 순수함수: 어떤 외부상태에 의존하지도 않고 변경하지도 않는, 부수효과없는 함수
   > 2. 비순수함수: 외부상태에 의존하거나 변경하는 부수효과있는 함수

```javascript
// 순수함수

var count = 0;
function increase(n) {
  return ++n;
}
// n이 계속 재할당되면서 변경

// 비순수함수

var count = 0;
function increase(n) {
  return ++count;
}
// 외부상태에 의존하며 변경
```

- 함수형 프로그래밍은 결국 순수함수를 통해 부수효과를 최대한 억제해 오류를 피하고 프로그램의 안정성을 높이려는 노력의 일환이다.
