> # 5.1 값

 - 값이란, **표현식이 평가되어 생성된 결과**를 말한다.

 - 모든 값은 **데이터 타입을 가지며**, 메모리에 **2진수로 저장**된다.
 
```
// 10 + 20은 평가되어 숫자 값 30을 생성한다
10 + 20; // 30
```

아래의 예제를 살펴보자

```
// 변수에는 10 + 20이 평가되어 생성된 숫자 값 30이 할당된다.
var sum = 10 + 20;
```

sum변수에 할당되는 것은 10 + 20이 아니라 10 + 20이 평가된 결과인 숫자 값인 30이다. 즉 **값이란 변수에 할당되는 것**이다.


> # 5.2 리터럴

- 값은 다양한 방법으로 생성할 수 있는데, 가장 기본적인 방법은 **리터럴**이다.

- **사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성**하는 표기법 이라고 한다.

```
100 // 정수 리터럴

10.5 // 부동 소수점 리터럴

0b01000001 // 2진수 리터럴

0o101 // 8진수 리터럴

0x41 // 16진수 리터럴

"Hello", "World" // 문자열 리터럴

true, false // 불리언 리터럴

null // null 리터럴

undefined // undefined 리터럴

{ name: "Lee" } // 객체 리터럴

[1, 2, 3] // 배열 리터럴

function() {} // 함수 리터럴

/[A-Z]+/g // 정규 표현식 리터럴

```

리터럴은 사람이 이해할 수 있는 문자 또는 미리 약속된 기호로 표기한 코드라고 설명되어있다. 즉 **리터럴은 값을 생성하기 위해 미리 약속한 표기법**이라고 할 수 있다. 위와 같이 리터럴을 사용하면 다양한 종류의 값을 생성할 수 있다.

> # 5.3 표현식


- 표현식이란, **값으로 평가될 수 있는 문**이다. 즉 **표현식이 평가되면 새로운 값을 생성하거나 기존값을 참조하는것**이다.

```
// 100은 리터럴이다. 리터럴 100은 평가되어 값을 생성하므로 리터럴 그 자체로 표현식이다.
var score1 = 100;

// 50 + 50은 리터럴과 연산자로 이루어져있다. 하지만 50 + 50도 평가되어 숫자 값 100을 생성하므로 표현식이다.
var score2 = 50 + 50;

// 변수 식별자를 참조하면 변수 값으로 평가된다. 식별자 참조는 값을 생성하지는 않지만 갑승로 평가되므로 표현식이다.
score1;

// 리터럴 표현식
10
"hello"

// 식별자 표현식(선언이 이미 존재한다고 가정)
sum
person.name
arr[1]

// 연산자 표현식
10 + 20
sum = 10
sum !== 10

// 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)
square()
person.getName()
```

위의 예제와 같이 표현식은 리터럴, 식별자, 연산자, 함수 호출 등의 조합으로 이루어질 수 있으며, **값으로 평가된다는 점**에서 모두 동일하다.
즉 **값으로 평가될 수 있는 문은 모두 표현식**이라고 보면된다.

```
// 표현식과 표현식이 평가된 값은 동등한 관계다.
// 표현식 1 + 2가 평가되어 값 3을 생성하므로
// 표현식 1 + 2와 값 3은 동등한 관계이다
var x = 1 + 2;

// 식별자 표현식 x는 3으로 평가된다.
x + 3; // 6
```

표현식은 값으로 평가된다. 즉 **표현식은 값처럼 사용**할 수 있으며, **값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다는 것**이다.

위의 예제처럼 x + 3은 표현식이다. + 연산자는 좌항과 우항의 값을 산술 연산하는 연산자이므로 좌항과 우항에는 숫자 값이 위치하여야하는데, 좌항 x를 살펴보면 식별자 표현식으로 되어있다. 즉 x는 할당되어있는 숫자 값 3으로 평가되어 숫자 값이 위치해야 할 자리에 표현식 x를 사용할 수 있다. 이처럼 **표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어낼 수 있다**.

> # 5.4 문

- 문은 **프로그램을 구성하는 기본 단위이자 최소 실행단위**이다. 문의 집합으로 이뤄진 것이 프로그램, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍이다.

- 문은 **여러 토큰으로 구성**되며,키워드, 식별자, 연산자, 리터럴, 세미콜론 등의 특수기호는 문법적인 의미를 가지며, **문법적으로 더 이상 나눌 수 없는 코드의 기본 요소**이다. 이러한 기본 요소들을 토큰이라 부른다.

```
// 변수 선언문
var x;

// 할당문
x = 5;

// 함수 선언문
function foo () {}

// 조건문
if (x > 1) {console.log(x);}

// 반복문
for (var i = 0; i < 2; i++) { console.log(i); }
```

이처럼 문은 **명령문**이라고도 부른다. 즉 문은 **컴퓨터에 내리는 명령**이다.

> # 5.5 세미콜론과 세미콜론 자동 삽입 기능

- 세미콜론은 **문의 종료**를 나타낸다. 즉 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다.

- if문, for문, 함수 등의 코드 블록은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문에 세미콜론을 붙이지 않아도된다.

```
function foo () {
    return 
    {}
    // ASI의 동작 결과 => return; {};
    // 개발자의 예측 => return {};
}

console.log(foo()); // undefined

var bar = function () {}
(function() {})();

// ASI의 동작 결과 => var bar = function () {}(function() {})();
// 개발자의 예측 => var bar = function () {}; (function() {})();
// TypeError: (intermediate value)(...) is not a function
```

위의 예제처럼 **세미콜론은 생략 가능**하다. 자바스크립트 엔진이 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 **세미콜론 자동 삽입 기능**(ASI)이 암묵적으로 수행되기 때문이다.

하지만 개발자의 예측과 ASI가 일치하지 않는 경우가 간혹 있어 제대로 활용되지 못하고 있다는 점이 있다. 생략 가능한 기능이 있지만 세미콜론을 사용하는 쪽으로 나아가보자

> # 5.6 표현식인 문과 표현식이 아닌 문

- 표현식은 문의 일부일 수도 있고, 그 자체로 문이 될 수도 있다.

- **표현식인 문은 값으로 평가될 수 있는 문**이며, **표현식이 아닌 문은 값으로 평가될 수 없는 문**을 말한다.

```
// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.
var x;

// 1, 2, 1 + 2, x = 1 + 2는 모두 표현식이다.
// x = 1 + 2는 표현식이면서 완전한 문이기도 하다.
x = 1 + 2;

// 표현식이 아닌 문은 값처럼 사용할 수 없다.
var foo = var x; // SyntaxError: Unexpected token var

// 변수 선언문은 표현식이 아닌 문이다.
var x;

// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉 할당문은 표현식인 문이다.
x = 100;

// 표현식인 문은 값처럼 사용할 수 있다.
var foo = x = 100;
console.log(foo); // 100
```

크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력하고, 이를 완료 값이라고 칭한다. 반대로 표현식인 문을 실행하면 언제나 평가된 값을 출력한다.